# v8 的垃圾回收机制

## 内存限制

v8 限制用户只能使用部分内存（当然，这个限制大小也可以用户自己设置，默认 64 位约为 1.4GB，32 位约为 0.7GB）

以 1.5GB 的垃圾回收堆内存为例，v8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式的垃圾回收甚至要 1 秒以上。在这样子时间开销下，性能和响应能力直线下降。

## 分代式垃圾回收机制

- 新生代空间：存放存活时间短的对象，主要采用 Scavenge 算法

- 老生代空间：存放存活时间长的对象，`标记清除算法` 搭配 `标记整理算法`

`标记清除算法` 先将存活的对象进行标记，清除时只清除没有标记的（老生代中都是生命周期长的对象，刚好死亡的对象少），不过此时会出现内存不连续的情况。但是，如果此时需要放一个大对象，则放不下，从而导致再次引起回收。然而这次回收是不必要的。

`标记整理算法` 先将死亡的对象进行标记，然后将存活得对象往一段移动，移动完成后，清理掉边界外的内存。

主要还是使用标记清除，只有在新生代发生晋升，导致老生代分配不出足够空间时，采用标记整理

## 增量标记

上述三种方式局限：都需要将应用暂停下来，等待执行回收，回收执行完毕才继续应用逻辑。特别是 v8 老生代，因为配置较大，存活的对象多，导致标记、清除、整理带来的停顿更加严重。

增量标记可以将上述步骤拆成更细的“粒度”，让回收中的标记阶段和应用逻辑交替进行，v8 引入这个方式后最大停顿减少到原本 1/6 (类似 React Fiber)
